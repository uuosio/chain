
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>test: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">test/generated.go (64.4%)</option>
				
				<option value="file1">test/main.go (98.3%)</option>
				
				<option value="file2">test/utils.go (100.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">
package main
import (
        "github.com/uuosio/chain"
    "github.com/uuosio/chain/database"
    "unsafe"
)

type sayhello struct {
    name string
}


func (t *sayhello) Pack() []byte <span class="cov0" title="0">{
    enc := chain.NewEncoder(t.Size())
        enc.PackString(t.name)
    return enc.GetBytes()
}</span>

func (t *sayhello) Unpack(data []byte) int <span class="cov8" title="1">{
    dec := chain.NewDecoder(data)
        t.name = dec.UnpackString()
    return dec.Pos()
}</span>

func (t *sayhello) Size() int <span class="cov0" title="0">{
    size := 0
        size += chain.PackedVarUint32Length(uint32(len(t.name))) + len(t.name) //name
    return size
}</span>

type saygoodbye struct {
    name string
}


func (t *saygoodbye) Pack() []byte <span class="cov0" title="0">{
    enc := chain.NewEncoder(t.Size())
        enc.PackString(t.name)
    return enc.GetBytes()
}</span>

func (t *saygoodbye) Unpack(data []byte) int <span class="cov8" title="1">{
    dec := chain.NewDecoder(data)
        t.name = dec.UnpackString()
    return dec.Pos()
}</span>

func (t *saygoodbye) Size() int <span class="cov0" title="0">{
    size := 0
        size += chain.PackedVarUint32Length(uint32(len(t.name))) + len(t.name) //name
    return size
}</span>

type inc struct {
    name string
}


func (t *inc) Pack() []byte <span class="cov0" title="0">{
    enc := chain.NewEncoder(t.Size())
        enc.PackString(t.name)
    return enc.GetBytes()
}</span>

func (t *inc) Unpack(data []byte) int <span class="cov8" title="1">{
    dec := chain.NewDecoder(data)
        t.name = dec.UnpackString()
    return dec.Pos()
}</span>

func (t *inc) Size() int <span class="cov0" title="0">{
    size := 0
        size += chain.PackedVarUint32Length(uint32(len(t.name))) + len(t.name) //name
    return size
}</span>

type test1 struct {
}


func (t *test1) Pack() []byte <span class="cov0" title="0">{
    enc := chain.NewEncoder(t.Size())
    return enc.GetBytes()
}</span>

func (t *test1) Unpack(data []byte) int <span class="cov8" title="1">{
    dec := chain.NewDecoder(data)
    return dec.Pos()
}</span>

func (t *test1) Size() int <span class="cov0" title="0">{
    size := 0
    return size
}</span>


func (t *Counter) Pack() []byte <span class="cov8" title="1">{
    enc := chain.NewEncoder(t.Size())
        enc.PackUint64(t.key)
        enc.PackUint64(t.count)
    return enc.GetBytes()
}</span>

func (t *Counter) Unpack(data []byte) int <span class="cov0" title="0">{
    dec := chain.NewDecoder(data)
        t.key = dec.UnpackUint64()
        t.count = dec.UnpackUint64()
    return dec.Pos()
}</span>

func (t *Counter) Size() int <span class="cov8" title="1">{
    size := 0
        size += 8 //key
        size += 8 //count
    return size
}</span>


func (t *MyData) Pack() []byte <span class="cov8" title="1">{
    enc := chain.NewEncoder(t.Size())
        enc.PackUint64(t.primary)
        enc.PackUint64(t.a1)
        enc.WriteBytes(t.a2[:])
        enc.Pack(&amp;t.a3)
        enc.PackFloat64(t.a4)
        enc.Pack(&amp;t.a5)
    return enc.GetBytes()
}</span>

func (t *MyData) Unpack(data []byte) int <span class="cov8" title="1">{
    dec := chain.NewDecoder(data)
        t.primary = dec.UnpackUint64()
        t.a1 = dec.UnpackUint64()
        dec.Unpack(&amp;t.a2)
        dec.UnpackI(&amp;t.a3)
        t.a4 = dec.UnpackFloat64()
        dec.UnpackI(&amp;t.a5)
    return dec.Pos()
}</span>

func (t *MyData) Size() int <span class="cov8" title="1">{
    size := 0
        size += 8 //primary
        size += 8 //a1
        size += 16 //a2
        size += 32 //a3
        size += 8 //a4
        size += t.a5.Size() //a5
    return size
}</span>

var (
        MyDataSecondaryTypes = []int{
                database.IDX64,
                database.IDX128,
                database.IDX256,
                database.IDXFloat64,
                database.IDXFloat128,
        }
)

func MyDataTableNameToIndex(indexName string) int <span class="cov0" title="0">{
        switch indexName </span>{
                case "a1":<span class="cov0" title="0">
                        return 0</span>
                case "a2":<span class="cov0" title="0">
                        return 1</span>
                case "a3":<span class="cov0" title="0">
                        return 2</span>
                case "a4":<span class="cov0" title="0">
                        return 3</span>
                case "a5":<span class="cov0" title="0">
                        return 4</span>
        default:<span class="cov0" title="0">
                panic("unknow indexName")</span>
        }
}

func MyDataUnpacker(buf []byte) database.MultiIndexValue <span class="cov8" title="1">{
        v := &amp;MyData{}
        v.Unpack(buf)
        return v
}</span>

func (t *MyData) GetSecondaryValue(index int) interface{} <span class="cov8" title="1">{
        switch index </span>{
                case 0:<span class="cov8" title="1">
                        return t.a1</span>
                case 1:<span class="cov8" title="1">
                        return t.a2</span>
                case 2:<span class="cov8" title="1">
                        return t.a3</span>
                case 3:<span class="cov8" title="1">
                        return t.a4</span>
                case 4:<span class="cov8" title="1">
                        return t.a5</span>
                default:<span class="cov0" title="0">
                        panic("index out of bound")</span>
        }
}

func (t *MyData) SetSecondaryValue(index int, v interface{}) <span class="cov8" title="1">{
        switch index </span>{
        case 0:<span class="cov8" title="1">
                t.a1 = v.(uint64)</span>
        case 1:<span class="cov8" title="1">
                t.a2 = v.(chain.Uint128)</span>
        case 2:<span class="cov8" title="1">
                t.a3 = v.(chain.Uint256)</span>
        case 3:<span class="cov8" title="1">
                t.a4 = v.(float64)</span>
        case 4:<span class="cov8" title="1">
                t.a5 = v.(chain.Float128)</span>
        default:<span class="cov0" title="0">
                panic("unknown index")</span>
        }
}

func (t *MyData) GetPrimary() uint64 <span class="cov8" title="1">{
    return t.primary
}</span>

type MyDataTable struct {
        database.MultiIndexInterface
}

func (mi *MyDataTable) Store(v *MyData, payer chain.Name) <span class="cov8" title="1">{
        mi.MultiIndexInterface.Store(v, payer)
}</span>

func (mi *MyDataTable) GetByKey(id uint64) (*database.Iterator, *MyData) <span class="cov8" title="1">{
        it, data := mi.MultiIndexInterface.GetByKey(id)
        if !it.IsOk() </span><span class="cov0" title="0">{
                return it, nil
        }</span>
        <span class="cov8" title="1">return it, data.(*MyData)</span>
}

func (mi *MyDataTable) GetByIterator(it *database.Iterator) *MyData <span class="cov8" title="1">{
        data := mi.MultiIndexInterface.GetByIterator(it)
        return data.(*MyData)
}</span>

func (mi *MyDataTable) Update(it *database.Iterator, v *MyData, payer chain.Name) <span class="cov0" title="0">{
        mi.MultiIndexInterface.Update(it, v, payer)
}</span>

func NewMyDataTable(code chain.Name, optionalScope ...chain.Name) *MyDataTable <span class="cov8" title="1">{
        var scope chain.Name
        if len(optionalScope) &gt; 0 </span><span class="cov0" title="0">{
                scope = optionalScope[0]
        }</span> else<span class="cov8" title="1"> {
                scope = chain.Name{N: 0}
        }</span>
        <span class="cov8" title="1">table := chain.Name{N:uint64(10921911446417702912)} //table name: MyData
        if table.N&amp;uint64(0x0f) != 0 </span><span class="cov0" title="0">{
                // Limit table names to 12 characters so that the last character (4 bits) can be used to distinguish between the secondary indices.
                panic("NewMultiIndex:Invalid multi-index table name ")</span>
        }

        <span class="cov8" title="1">mi := &amp;database.MultiIndex{}
        mi.SetTable(code, scope, table)
        mi.Table = database.NewTableI64(code, scope, table, func(data []byte) database.TableValue </span><span class="cov0" title="0">{
                return mi.Unpack(data)
        }</span>)
        <span class="cov8" title="1">mi.IdxTableNameToIndex = MyDataTableNameToIndex
        mi.IndexTypes = MyDataSecondaryTypes
        mi.IDXTables = make([]database.SecondaryTable, len(MyDataSecondaryTypes))
        mi.Unpack = MyDataUnpacker
        mi.IDXTables[0] = database.NewIdxTable64(0, code.N, scope.N, uint64(10921911446417702912)+0)
        mi.IDXTables[1] = database.NewIdxTable128(1, code.N, scope.N, uint64(10921911446417702912)+1)
        mi.IDXTables[2] = database.NewIdxTable256(2, code.N, scope.N, uint64(10921911446417702912)+2)
        mi.IDXTables[3] = database.NewIdxTableFloat64(3, code.N, scope.N, uint64(10921911446417702912)+3)
        mi.IDXTables[4] = database.NewIdxTableFloat128(4, code.N, scope.N, uint64(10921911446417702912)+4)
        return &amp;MyDataTable{mi}</span>
}
func (mi *MyDataTable) GetIdxTableBya1() *database.IdxTable64 <span class="cov8" title="1">{
        return mi.GetIdxTableByIndex(0).(*database.IdxTable64)
}</span>
func (mi *MyDataTable) GetIdxTableBya2() *database.IdxTable128 <span class="cov8" title="1">{
        return mi.GetIdxTableByIndex(1).(*database.IdxTable128)
}</span>
func (mi *MyDataTable) GetIdxTableBya3() *database.IdxTable256 <span class="cov8" title="1">{
        return mi.GetIdxTableByIndex(2).(*database.IdxTable256)
}</span>
func (mi *MyDataTable) GetIdxTableBya4() *database.IdxTableFloat64 <span class="cov8" title="1">{
        return mi.GetIdxTableByIndex(3).(*database.IdxTableFloat64)
}</span>
func (mi *MyDataTable) GetIdxTableBya5() *database.IdxTableFloat128 <span class="cov8" title="1">{
        return mi.GetIdxTableByIndex(4).(*database.IdxTableFloat128)
}</span>

var (
        CounterSecondaryTypes = []int{
        }
)

func CounterTableNameToIndex(indexName string) int <span class="cov0" title="0">{
        switch indexName </span>{
        default:<span class="cov0" title="0">
                panic("unknow indexName")</span>
        }
}

func CounterUnpacker(buf []byte) database.MultiIndexValue <span class="cov0" title="0">{
        v := &amp;Counter{}
        v.Unpack(buf)
        return v
}</span>

func (t *Counter) GetSecondaryValue(index int) interface{} <span class="cov0" title="0">{
        switch index </span>{
                default:<span class="cov0" title="0">
                        panic("index out of bound")</span>
        }
}

func (t *Counter) SetSecondaryValue(index int, v interface{}) <span class="cov0" title="0">{
        switch index </span>{
        default:<span class="cov0" title="0">
                panic("unknown index")</span>
        }
}

func (t *Counter) GetPrimary() uint64 <span class="cov8" title="1">{
    return t.key
}</span>

type CounterTable struct {
        database.MultiIndexInterface
}

func (mi *CounterTable) Store(v *Counter, payer chain.Name) <span class="cov8" title="1">{
        mi.MultiIndexInterface.Store(v, payer)
}</span>

func (mi *CounterTable) GetByKey(id uint64) (*database.Iterator, *Counter) <span class="cov0" title="0">{
        it, data := mi.MultiIndexInterface.GetByKey(id)
        if !it.IsOk() </span><span class="cov0" title="0">{
                return it, nil
        }</span>
        <span class="cov0" title="0">return it, data.(*Counter)</span>
}

func (mi *CounterTable) GetByIterator(it *database.Iterator) *Counter <span class="cov0" title="0">{
        data := mi.MultiIndexInterface.GetByIterator(it)
        return data.(*Counter)
}</span>

func (mi *CounterTable) Update(it *database.Iterator, v *Counter, payer chain.Name) <span class="cov0" title="0">{
        mi.MultiIndexInterface.Update(it, v, payer)
}</span>

func NewCounterTable(code chain.Name, optionalScope ...chain.Name) *CounterTable <span class="cov8" title="1">{
        var scope chain.Name
        if len(optionalScope) &gt; 0 </span><span class="cov8" title="1">{
                scope = optionalScope[0]
        }</span> else<span class="cov0" title="0"> {
                scope = chain.Name{N: 0}
        }</span>
        <span class="cov8" title="1">table := chain.Name{N:uint64(4986958866982895616)} //table name: Counter
        if table.N&amp;uint64(0x0f) != 0 </span><span class="cov0" title="0">{
                // Limit table names to 12 characters so that the last character (4 bits) can be used to distinguish between the secondary indices.
                panic("NewMultiIndex:Invalid multi-index table name ")</span>
        }

        <span class="cov8" title="1">mi := &amp;database.MultiIndex{}
        mi.SetTable(code, scope, table)
        mi.Table = database.NewTableI64(code, scope, table, func(data []byte) database.TableValue </span><span class="cov0" title="0">{
                return mi.Unpack(data)
        }</span>)
        <span class="cov8" title="1">mi.IdxTableNameToIndex = CounterTableNameToIndex
        mi.IndexTypes = CounterSecondaryTypes
        mi.IDXTables = make([]database.SecondaryTable, len(CounterSecondaryTypes))
        mi.Unpack = CounterUnpacker
        return &amp;CounterTable{mi}</span>
}


//eliminate unused package errors
func dummy() <span class="cov0" title="0">{
        if false </span><span class="cov0" title="0">{
                v := 0;
                n := unsafe.Sizeof(v);
                chain.Printui(uint64(n));
                chain.Printui(database.IDX64);
        }</span>
}

func main() <span class="cov0" title="0">{
        receiver, firstReceiver, action := chain.GetApplyArgs()
        contract_apply(receiver.N, firstReceiver.N, action.N)
}</span>

func contract_apply(_receiver, _firstReceiver, _action uint64) <span class="cov8" title="1">{
        receiver := chain.Name{_receiver}
        firstReceiver := chain.Name{_firstReceiver}
        action := chain.Name{_action}

        contract := NewContract(receiver, firstReceiver, action)
        if contract == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">data := chain.ReadActionData()
        
        //Fix data declared but not used error
        if false </span><span class="cov0" title="0">{
                println(len(data))
        }</span>

    <span class="cov8" title="1">if receiver == firstReceiver </span><span class="cov8" title="1">{
        switch action.N </span>{
        case uint64(13960267442438537216):<span class="cov8" title="1"> //sayhello
            t := sayhello{}
            t.Unpack(data)
            contract.SayHello(t.name)</span>
        case uint64(13960255394853060608):<span class="cov8" title="1"> //saygoodbye
            t := saygoodbye{}
            t.Unpack(data)
            contract.SayGoodbye(t.name)</span>
        case uint64(8417227703555457024):<span class="cov8" title="1"> //inc
            t := inc{}
            t.Unpack(data)
            contract.Inc(t.name)</span>
        case uint64(14605613945969442816):<span class="cov8" title="1"> //test1
            t := test1{}
            t.Unpack(data)
            contract.test1()</span>
        }
    }
    <span class="cov8" title="1">if receiver != firstReceiver </span><span class="cov0" title="0">{
        switch action.N </span>{
        }
    }
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package main

import (
        "github.com/uuosio/chain"
)
import "C"

//table mydata
type MyData struct {
        primary uint64         //primary
        a1      uint64         //secondary
        a2      chain.Uint128  //secondary
        a3      chain.Uint256  //secondary
        a4      float64        //secondary
        a5      chain.Float128 //secondary
}

//contract test
type Contract struct {
        receiver      chain.Name
        firstReceiver chain.Name
        action        chain.Name
}

func NewContract(receiver, firstReceiver, action chain.Name) *Contract <span class="cov8" title="1">{
        return &amp;Contract{
                receiver,
                firstReceiver,
                action,
        }
}</span>

//action sayhello
func (c *Contract) SayHello(name string) <span class="cov8" title="1">{
        chain.Prints("++++++hello,world")
        chain.NewAction(
                chain.NewPermissionLevel(chain.NewName("hello"), chain.NewName("active")),
                chain.NewName("hello"),
                chain.NewName("saygoodbye"),
                "+++++++++++goodbye, world",
        ).Send()
}</span>

//action saygoodbye
func (c *Contract) SayGoodbye(name string) <span class="cov8" title="1">{
        chain.Prints("+++++++goodbye world")
}</span>

//action inc
func (c *Contract) Inc(name string) <span class="cov8" title="1">{
        db := NewCounterTable(c.receiver, c.receiver)
        it := db.Find(1)
        payer := c.receiver
        if it.IsOk() </span><span class="cov0" title="0">{
                value := db.GetByIterator(it)
                value.count += 1
                db.Update(it, value, payer)
                chain.Println("count: ", value.count)
        }</span> else<span class="cov8" title="1"> {
                value := &amp;Counter{
                        key:   1,
                        count: 1,
                }
                db.Store(value, payer)
                chain.Println("count: ", value.count)
        }</span>
}

func (t *Contract) initTest() *MyDataTable <span class="cov8" title="1">{
        payer := t.receiver

        mi := NewMyDataTable(t.receiver)

        data := &amp;MyData{}
        data.primary = 1
        data.a1 = 1
        data.a2 = chain.NewUint128(2, 0)
        data.a3 = chain.NewUint256(3, 0, 0, 0)
        data.a4 = 4.0
        data.a5 = chain.NewFloat128(5.0)
        mi.Store(data, payer)

        data = &amp;MyData{}
        data.primary = 11
        data.a1 = 11
        data.a2 = chain.NewUint128(22, 0)
        data.a3 = chain.NewUint256(33, 0, 0, 0)
        data.a4 = 44.0
        data.a5 = chain.NewFloat128(55.0)
        mi.Store(data, payer)

        data = &amp;MyData{}
        data.primary = 111
        data.a1 = 111
        data.a2 = chain.NewUint128(222, 0)
        data.a3 = chain.NewUint256(333, 0, 0, 0)
        data.a4 = 444.0
        data.a5 = chain.NewFloat128(555.0)
        mi.Store(data, payer)
        return mi
}</span>

//action test1
func (t *Contract) test1() <span class="cov8" title="1">{
        payer := t.receiver
        mi := t.initTest()
        </span><span class="cov8" title="1">{
                check(mi.Find(1).IsOk(), "mi.Find(1).IsOk()")
                it := mi.Lowerbound(1)
                check(it.IsOk(), "mi.Lowerbound(1)")

                it = mi.Lowerbound(2)
                check(it.IsOk(), "mi.Lowerbound(2)")
                check(mi.GetByIterator(it).primary == 11, "mi.Lowerbound(2)")

                it = mi.Upperbound(1)
                check(it.IsOk(), "mi.Upperbound(1)")
                check(mi.GetByIterator(it).primary == 11, "mi.Upperbound(1)")

                it = mi.Find(1)
                check(it.IsOk(), "mi.Find(1).IsOk()")
                it, primary := mi.Next(it)
                check(it.IsOk(), "mi.Next(it)")
                check(primary == 11, "mi.Next(it)")

                data := mi.GetByIterator(it)
                check(data.primary == 11, "data.primary == 11")
                check(data.a1 == 11, "data.a1 == 11")
                check(data.a2 == chain.NewUint128(22, 0), "data.a2 == *chain.NewUint128(22, 0)")
                check(data.a3 == chain.NewUint256(33, 0, 0, 0), "data.a3 == *chain.NewUint256(33, 0, 0, 0)")
                check(data.a4 == 44.0, "data.a4 == 44.0")
                check(data.a5 == chain.NewFloat128(55.0), "data.a5 == *chain.NewFloat128(55.0)")

                it, primary = mi.Previous(it)
                data = mi.GetByIterator(it)
                check(data.primary == 1, "data.primary == 1")
                check(data.a1 == 1, "data.a1 == 1")
                check(data.a2 == chain.NewUint128(2, 0), "data.a2 == *chain.NewUint128(2, 0)")
                check(data.a3 == chain.NewUint256(3, 0, 0, 0), "data.a3 == *chain.NewUint256(3, 0, 0, 0)")
                check(data.a4 == 4.0, "data.a4 == 4.0")
                check(data.a5 == chain.NewFloat128(5.0), "data.a5 == *chain.NewFloat128(5.0)")

                it = mi.End()
                it, primary = mi.Previous(it)
                data = mi.GetByIterator(it)
                check(data.primary == 111, "data.primary == 1")
                check(data.a1 == 111, "data.a1 == 1")
                check(data.a2 == chain.NewUint128(222, 0), "data.a2 == *chain.NewUint128(222, 0)")
                check(data.a3 == chain.NewUint256(333, 0, 0, 0), "data.a3 == *chain.NewUint256(333, 0, 0, 0)")
                check(data.a4 == 444.0, "data.a4 == 4.0")
                check(data.a5 == chain.NewFloat128(555.0), "data.a5 == *chain.NewFloat128(555.0)")
        }</span>

        <span class="cov8" title="1">{
                idx64 := mi.GetIdxTableBya1()
                it, secondary := idx64.Lowerbound(1)
                check(it.IsOk(), "idx64.Lowerbound(1)")
                check(secondary == 1, "secondary == 1")

                it, secondary = idx64.Upperbound(1)
                check(it.IsOk(), "idx64.Upperbound(1)")
                check(secondary == 11, "secondary == 11")

                it = idx64.Find(1)
                check(it.IsOk(), "idx64.Find(1)")
                check(it.Primary == 1, "it.Primary == 1")

                it = idx64.Next(it)
                check(it.IsOk(), "idx64.Next(it)")
                check(it.Primary == 11, "idx64.Next(it)")

                it = idx64.Previous(it)
                check(it.IsOk(), "idx64.Previous(it)")
                check(it.Primary == 1, "idx64.Previous(it)")

                it = idx64.End()
                it = idx64.Previous(it)
                check(it.IsOk(), "idx64.End()")
                check(it.Primary == 111, "idx64.End()")
        }</span>

        <span class="cov8" title="1">{
                idx128 := mi.GetIdxTableBya2()
                it, secondary := idx128.Lowerbound(chain.NewUint128(2, 0))
                check(it.IsOk(), "idx128.Lowerbound(1)")
                check(secondary == chain.NewUint128(2, 0), "secondary == chain.NewUint128(2, 0)")

                it, secondary = idx128.Upperbound(chain.NewUint128(2, 0))
                check(it.IsOk(), "idx128.Upperbound(chain.NewUint128(1, 0))")
                check(secondary == chain.NewUint128(22, 0), "*secondary == *chain.NewUint128(11, 0)")

                it = idx128.Find(chain.NewUint128(2, 0))
                check(it.IsOk(), "idx128.Find(chain.NewUint128(1, 0))")
                check(it.Primary == 1, "it.Primary == 11")

                it = idx128.Next(it)
                check(it.IsOk(), "idx128.Next(it)")
                check(it.Primary == 11, "idx128.Next(it)")

                it = idx128.Previous(it)
                check(it.IsOk(), "idx128.Previous(it)")
                check(it.Primary == 1, "idx128.Previous(it)")

                it = idx128.End()
                it = idx128.Previous(it)
                check(it.IsOk(), "idx128.End()")
                check(it.Primary == 111, "idx128.End()")
        }</span>

        <span class="cov8" title="1">{
                idx256 := mi.GetIdxTableBya3()
                it, secondary := idx256.Lowerbound(chain.NewUint256(3, 0, 0, 0))
                check(it.IsOk(), "idx256.Lowerbound(1)")
                check(secondary == chain.NewUint256(3, 0, 0, 0), "secondary == chain.NewUint256(3, 0, 0, 0)")

                it, secondary = idx256.Upperbound(chain.NewUint256(3, 0, 0, 0))
                check(it.IsOk(), "idx256.Upperbound(chain.NewUint128(1, 0))")
                check(secondary == chain.NewUint256(33, 0, 0, 0), "secondary == *chain.NewUint256(33, 0, 0, 0)")

                it = idx256.Find(chain.NewUint256(3, 0, 0, 0))
                check(it.IsOk(), "idx256.Find(chain.NewUint256(3, 0, 0, 0))")
                check(it.Primary == 1, "it.Primary == 11")

                it = idx256.Next(it)
                check(it.IsOk(), "idx256.Next(it)")
                check(it.Primary == 11, "idx256.Next(it)")

                it = idx256.Previous(it)
                check(it.IsOk(), "idx256.Previous(it)")
                check(it.Primary == 1, "idx256.Previous(it)")

                it = idx256.End()
                it = idx256.Previous(it)
                check(it.IsOk(), "idx256.End()")
                check(it.Primary == 111, "idx256.End()")
        }</span>

        <span class="cov8" title="1">{
                idxf64 := mi.GetIdxTableBya4()
                it, secondary := idxf64.Lowerbound(4.0)
                check(it.IsOk(), "idxf64.Lowerbound(4.0)")
                check(secondary == 4.0, "secondary == 4.0")

                it, secondary = idxf64.Upperbound(4.0)
                check(it.IsOk(), "idxf64.Upperbound(4.0)")
                check(secondary == 44.0, "secondary == 44.0")

                it = idxf64.Find(4.0)
                check(it.IsOk(), "idxf64.Find(4.0)")
                check(it.Primary == 1, "it.Primary == 1")

                it = idxf64.Next(it)
                check(it.IsOk(), "idxf64.Next(it)")
                check(it.Primary == 11, "idxf64.Next(it)")

                it = idxf64.Previous(it)
                check(it.IsOk(), "idxf64.Previous(it)")
                check(it.Primary == 1, "idxf64.Previous(it)")

                it = idxf64.End()
                it = idxf64.Previous(it)
                check(it.IsOk(), "idxf64.End()")
                check(it.Primary == 111, "idxf64.End()")
        }</span>

        <span class="cov8" title="1">{
                idxf128 := mi.GetIdxTableBya5()
                it, secondary := idxf128.Lowerbound(chain.NewFloat128(5.0))
                check(it.IsOk(), "idxf128.Lowerbound(1)")
                check(secondary == chain.NewFloat128(5.0), "secondary == chain.NewFloat128(5.0)")

                it, secondary = idxf128.Upperbound(chain.NewFloat128(5.0))
                check(it.IsOk(), "idxf128.Upperbound(chain.NewFloat128(5.0))")
                check(secondary == chain.NewFloat128(55.0), "secondary == chain.NewFloat128(55.0)")

                it = idxf128.Find(chain.NewFloat128(5.0))
                check(it.IsOk(), "idxf128.Find(chain.NewFloat128(5.0))")
                check(it.Primary == 1, "it.Primary == 1")

                it = idxf128.Next(it)
                check(it.IsOk(), "idxf128.Next(it)")
                check(it.Primary == 11, "idxf128.Next(it)")

                it = idxf128.Previous(it)
                check(it.IsOk(), "idxf128.Previous(it)")
                check(it.Primary == 1, "idxf128.Previous(it)")

                it = idxf128.End()
                it = idxf128.Previous(it)
                check(it.IsOk(), "idxf128.End()")
                check(it.Primary == 111, "idxf128.End()")
        }</span>
        // {
        //         it, data := mi.GetByKey(1)
        //         check(it.IsOk(), "bad value")
        //         check(data.primary == 1, "bad value")
        //         mi.Update(it, data, payer)
        // }
        <span class="cov8" title="1">{
                idx64 := mi.GetIdxTableBya1()
                it := idx64.Find(1)
                check(it.IsOk(), "idx64.Find(1)")
                mi.IdxUpdate(it, uint64(2), payer)
                itPrimary, data := mi.GetByKey(it.Primary)
                check(itPrimary.IsOk(), "mi.GetByKey(it.Primary)")
                check(data.primary == 1, "data.primary == 1")
                check(data.a1 == 2, "data.a1 == 2")
        }</span>

        <span class="cov8" title="1">{
                idx128 := mi.GetIdxTableBya2()
                it := idx128.Find(chain.NewUint128(2, 0))
                check(it.IsOk(), "idx128.Find(chain.NewUint128(2, 0))")
                mi.IdxUpdate(it, chain.NewUint128(3, 0), payer)
                itPrimary, data := mi.GetByKey(it.Primary)
                check(itPrimary.IsOk(), "mi.GetByKey(it.Primary)")
                check(data.primary == 1, "data.primary == 1")
                check(data.a2 == chain.NewUint128(3, 0), "data.a1 == 2")
        }</span>

        <span class="cov8" title="1">{
                idx256 := mi.GetIdxTableBya3()
                it := idx256.Find(chain.NewUint256(3, 0, 0, 0))
                check(it.IsOk(), "idx256.Find(chain.NewUint256(3, 0, 0, 0))")
                mi.IdxUpdate(it, chain.NewUint256(4, 0, 0, 0), payer)
                itPrimary, data := mi.GetByKey(it.Primary)
                check(itPrimary.IsOk(), "mi.GetByKey(it.Primary)")
                check(data.primary == 1, "data.primary == 1")
                check(data.a3 == chain.NewUint256(4, 0, 0, 0), "data.a3 == chain.NewUint256(4, 0, 0, 0)")
        }</span>

        <span class="cov8" title="1">{
                idxf64 := mi.GetIdxTableBya4()
                it := idxf64.Find(4.0)
                check(it.IsOk(), "idx64.Find(4.0)")
                mi.IdxUpdate(it, float64(5.0), payer)
                itPrimary, data := mi.GetByKey(it.Primary)
                check(itPrimary.IsOk(), "mi.GetByKey(it.Primary)")
                check(data.primary == 1, "data.primary == 1")
                check(data.a4 == 5.0, "data.a4 == 5.0")
        }</span>
        <span class="cov8" title="1">{
                idxf128 := mi.GetIdxTableBya5()
                it := idxf128.Find(chain.NewFloat128(5.0))
                check(it.IsOk(), "idx64.Find(chain.NewFloat128(5.0))")
                mi.IdxUpdate(it, chain.NewFloat128(6.0), payer)
                itPrimary, data := mi.GetByKey(it.Primary)
                check(itPrimary.IsOk(), "mi.GetByKey(it.Primary)")
                check(data.primary == 1, "data.primary == 1")
                check(data.a5 == chain.NewFloat128(6.0), "data.a5 == 6.0")
        }</span>

        <span class="cov8" title="1">{
                it := mi.Find(1)
                mi.Remove(it)

                it = mi.Find(11)
                mi.Remove(it)

                it = mi.Find(111)
                mi.Remove(it)

                it = mi.Find(1)
                check(!it.IsOk(), "bad")

                it = mi.Find(11)
                check(!it.IsOk(), "bad")

                it = mi.Find(111)
                check(!it.IsOk(), "bad")
        }</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package main

import (
        "github.com/uuosio/chain"
)

func check(b bool, msg string) <span class="cov8" title="1">{
        chain.Check(b, msg)
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
